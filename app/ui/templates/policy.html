{% extends "base.html" %}
{% block title %}Guardrail Admin · Policy{% endblock %}

{% block content %}
<section class="container" style="max-width: 900px; margin: 2rem auto;">
  <h1>Policy</h1>
  <p class="muted">View the active policy version (from merged packs) and reload if packs change.</p>

  <div class="card" style="padding: 1rem 1.25rem; margin-top: 1rem;">
    <h2 style="margin-top:0;">Active Version</h2>
    <div id="versionBox"
         style="font-family: ui-monospace, SFMono-Regular, Menlo, monospace; word-break: break-all; background:#f9fafb; border:1px solid #e5e7eb; border-radius:.5rem; padding:.5rem .75rem;">
      {{ version }}
    </div>
    <details style="margin-top:.75rem;">
      <summary><strong>Packs</strong></summary>
      <ul>
        {% for p in packs %}
        <li>{{ p }}</li>
        {% endfor %}
      </ul>
    </details>

    <div style="margin-top:1rem; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;">
      <label>
        <span style="display:block; font-size:.9rem; color:#555;">Admin key (optional)</span>
        <input id="adminKey" type="password" placeholder="Only if RBAC is enabled"
               style="min-width: 260px; padding:.45rem .6rem; border:1px solid #d1d5db; border-radius:.5rem;">
      </label>

      <button id="reloadBtn" class="btn primary">Reload Policy</button>
      <span id="statusMsg" class="muted" style="margin-left:.5rem;"></span>
    </div>
    <pre id="policy_reload_msg" class="muted" style="white-space:pre-wrap;margin-top:.5rem;"></pre>
    <details style="margin-top:8px;">
      <summary><strong>Policy Diff (current → candidate)</strong></summary>
      <pre id="policy_diff" class="muted" style="white-space:pre-wrap;"></pre>
    </details>
    <details style="margin-top:8px;">
      <summary><strong>Lint Results</strong> <span id="lint_summary" class="muted"></span></summary>
      <div class="lint-panel">
        <div class="lint-toolbar" role="toolbar" aria-label="Lint severity filter">
          <button id="filter-error" class="lint-filter-btn" type="button" aria-pressed="true">Errors</button>
          <button id="filter-warn" class="lint-filter-btn" type="button" aria-pressed="true">Warnings</button>
          <button id="filter-info" class="lint-filter-btn" type="button" aria-pressed="true">Info</button>
          <button id="copy-lints-json" class="lint-copy-btn" type="button">Copy as JSON</button>
          <span id="copy-toast" class="lint-toast muted" role="status" aria-live="polite" style="display:none;"></span>
        </div>
        <div id="lints-list" class="lint-list" role="list"></div>
      </div>
      <script id="lints-data" type="application/json">{{ lints | default([]) | tojson }}</script>
    </details>
  </div>

  <div class="card" style="padding: 1rem 1.25rem; margin-top: 1.5rem;">
    <strong>Validate Pack</strong>
    <p class="muted">Paste a YAML pack to lint before upload/activation.</p>
    <textarea id="pack_text" rows="8" style="width:100%;"></textarea>
    <button id="btn_validate" class="badge" style="margin-top:6px;">Validate</button>
    <pre id="validate_out"
         style="white-space:pre-wrap;background:#0b1020;color:#e5e7eb;padding:8px;border-radius:8px;max-height:240px;overflow:auto;"></pre>
  </div>
</section>

<style>
  .btn { padding:.5rem .85rem; border-radius:.5rem; border:1px solid #ccc; background:#f6f6f6; cursor:pointer; }
  .btn.primary { background:#2563eb; border-color:#2563eb; color:white; }
  .muted { color:#666; }
  .card { border:1px solid #e5e7eb; border-radius:.75rem; background:white; }
  .lint-panel { margin-top:.75rem; border:1px solid #e5e7eb; border-radius:.75rem; padding:.75rem; background:#f9fafb; }
  .lint-toolbar { display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; margin-bottom:.75rem; }
  .lint-filter-btn { background:white; border:1px solid #d1d5db; border-radius:9999px; padding:.35rem .9rem; font-size:.9rem; }
  .lint-filter-btn[aria-pressed="true"] { background:#1d4ed8; color:white; border-color:#1d4ed8; }
  .lint-copy-btn { margin-left:auto; background:#065f46; color:#fff; border-color:#065f46; padding:.35rem .9rem; border-radius:9999px; font-size:.9rem; }
  .lint-copy-btn:disabled { opacity:.6; cursor:not-allowed; }
  .lint-toast { margin-left:.5rem; font-size:.9rem; }
  .lint-list { display:flex; flex-direction:column; gap:.5rem; }
  .lint-row { display:flex; gap:.75rem; align-items:flex-start; padding:.5rem .75rem; background:white; border-radius:.5rem; border:1px solid #e5e7eb; }
  .lint-row[data-severity="error"] { border-color:#b91c1c; }
  .lint-row[data-severity="warn"] { border-color:#f59e0b; }
  .lint-row[data-severity="info"] { border-color:#2563eb; }
  .lint-badge { display:inline-block; min-width:3.5rem; text-align:center; padding:.2rem .5rem; border-radius:9999px; font-weight:600; font-size:.8rem; text-transform:uppercase; letter-spacing:.03em; }
  .lint-badge-error { background:#991b1b; color:#fff; }
  .lint-badge-warn { background:#f59e0b; color:#111827; }
  .lint-badge-info { background:#2563eb; color:#fff; }
  .lint-body { flex:1; min-width:0; }
  .lint-header { display:flex; flex-wrap:wrap; gap:.5rem; font-size:.85rem; margin-bottom:.25rem; }
  .lint-header code { background:#f3f4f6; padding:.1rem .35rem; border-radius:.35rem; }
  .lint-message { font-size:.95rem; margin-bottom:.25rem; }
  .lint-meta { font-size:.8rem; color:#4b5563; display:flex; flex-wrap:wrap; gap:.5rem; }
  .lint-meta-label { font-weight:600; }
  .lint-empty { font-size:.9rem; }
</style>

<script>
  (function () {
    const btn = document.getElementById('reloadBtn');
    const msg = document.getElementById('statusMsg');
    const vbox = document.getElementById('versionBox');
    const adminKey = document.getElementById('adminKey');
    const validateBtn = document.getElementById('btn_validate');
    const packInput = document.getElementById('pack_text');
    const validateOut = document.getElementById('validate_out');
    const reloadOut = document.getElementById('policy_reload_msg');
    const diffOut = document.getElementById('policy_diff');
    const lintSummary = document.getElementById('lint_summary');
    const lintsList = document.getElementById('lints-list');
    const lintDataScript = document.getElementById('lints-data');
    const filterButtons = {
      error: document.getElementById('filter-error'),
      warn: document.getElementById('filter-warn'),
      info: document.getElementById('filter-info'),
    };
    const copyBtn = document.getElementById('copy-lints-json');
    const copyToast = document.getElementById('copy-toast');
    const csrf = {{ csrf_token|tojson }};
    let toastTimer = null;
    const lintState = {
      items: [],
      filters: { error: true, warn: true, info: true },
    };

    function parseInitialLints() {
      if (!lintDataScript) {
        return [];
      }
      try {
        const raw = lintDataScript.textContent || '[]';
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (err) {
        return [];
      }
    }

    function getSeverity(lint) {
      const raw = lint && (lint.severity || lint.level || lint.type);
      const value = typeof raw === 'string' ? raw.toLowerCase() : '';
      if (value === 'error') return 'error';
      if (value === 'warn' || value === 'warning') return 'warn';
      if (value === 'info' || value === 'information') return 'info';
      return 'info';
    }

    function escapeHtml(value) {
      if (value === undefined || value === null) return '';
      return String(value).replace(/[&<>"']/g, (ch) => {
        switch (ch) {
          case '&':
            return '&amp;';
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
          case '"':
            return '&quot;';
          case '\'':
            return '&#39;';
          default:
            return ch;
        }
      });
    }

    function severityBadge(severity) {
      const sev = severity || 'info';
      const classes = {
        error: 'lint-badge lint-badge-error',
        warn: 'lint-badge lint-badge-warn',
        info: 'lint-badge lint-badge-info',
      };
      const cls = classes[sev] || 'lint-badge';
      const label = sev === 'warn' ? 'warning' : sev;
      return `<span class="${cls}" aria-label="severity: ${escapeHtml(label)}">${escapeHtml(label.toUpperCase())}</span>`;
    }

    function lintIdentifiers(lint) {
      const bits = [];
      const rule = lint && (lint.rule_id || lint.ruleId || lint.ruleID);
      const code = lint && (lint.code || lint.id);
      if (rule) {
        bits.push(`<code>${escapeHtml(rule)}</code>`);
      }
      if (code && code !== rule) {
        bits.push(`<code>${escapeHtml(code)}</code>`);
      }
      return bits.join(' ');
    }

    function lintMeta(lint) {
      const parts = [];
      const path = lint && (lint.path || lint.pointer);
      const line = lint && (lint.line ?? lint.line_number ?? lint.lineno);
      const column = lint && (lint.column ?? lint.col ?? lint.column_number);
      const offset = lint && (lint.offset ?? lint.position);
      if (path) {
        parts.push(`<span class="lint-meta-label">Path:</span> <code>${escapeHtml(path)}</code>`);
      }
      const extras = [];
      if (line !== undefined && line !== null) {
        extras.push(`line ${escapeHtml(String(line))}`);
      }
      if (column !== undefined && column !== null) {
        extras.push(`col ${escapeHtml(String(column))}`);
      }
      if (offset !== undefined && offset !== null) {
        extras.push(`offset ${escapeHtml(String(offset))}`);
      }
      if (extras.length) {
        parts.push(`<span class="lint-meta-label">Position:</span> ${escapeHtml(extras.join(', '))}`);
      }
      if (!parts.length) {
        return '';
      }
      return `<div class="lint-meta">${parts.join(' · ')}</div>`;
    }

    function lintRowTemplate(lint) {
      const severity = getSeverity(lint);
      const message = lint && (lint.message || lint.msg) ? lint.message || lint.msg : '';
      const segments = [];
      const identifiers = lintIdentifiers(lint);
      if (identifiers) {
        segments.push(`<div class="lint-header">${identifiers}</div>`);
      }
      segments.push(`<div class="lint-message">${escapeHtml(message)}</div>`);
      const meta = lintMeta(lint);
      if (meta) {
        segments.push(meta);
      }
      return `<div class="lint-row" data-severity="${escapeHtml(severity)}" role="listitem">${severityBadge(severity)}<div class="lint-body">${segments.join('')}</div></div>`;
    }

    function updateSummary() {
      if (!lintSummary) return;
      const counts = { error: 0, warn: 0, info: 0 };
      lintState.items.forEach((lint) => {
        const sev = getSeverity(lint);
        if (counts[sev] === undefined) {
          counts[sev] = 0;
        }
        counts[sev] += 1;
      });
      lintSummary.textContent = `errors: ${counts.error || 0}, warnings: ${counts.warn || 0}, info: ${counts.info || 0}`;
    }

    function updateScriptTag() {
      if (lintDataScript) {
        lintDataScript.textContent = JSON.stringify(lintState.items, null, 2);
      }
    }

    function applyFilter() {
      if (!lintsList) return;
      const rows = lintsList.querySelectorAll('.lint-row');
      if (!rows.length) return;
      let visibleCount = 0;
      rows.forEach((row) => {
        const sev = row.getAttribute('data-severity') || 'info';
        const show = Boolean(lintState.filters[sev]);
        row.style.display = show ? '' : 'none';
        if (show) {
          visibleCount += 1;
        }
      });
      let emptyFilter = lintsList.querySelector('.lint-empty-filter');
      if (visibleCount === 0) {
        if (!emptyFilter) {
          emptyFilter = document.createElement('div');
          emptyFilter.className = 'lint-empty lint-empty-filter muted';
          emptyFilter.setAttribute('role', 'note');
          emptyFilter.textContent = 'No lints match the selected filters.';
          lintsList.appendChild(emptyFilter);
        }
        emptyFilter.style.display = 'block';
      } else if (emptyFilter) {
        emptyFilter.style.display = 'none';
      }
    }

    function renderLintRows() {
      if (!lintsList) return;
      if (!lintState.items.length) {
        lintsList.innerHTML = '<div class="lint-empty muted" role="note">No lints found.</div>';
        return;
      }
      lintsList.innerHTML = lintState.items.map((lint) => lintRowTemplate(lint)).join('');
      applyFilter();
    }

    function renderLints(lints) {
      lintState.items = Array.isArray(lints) ? lints : [];
      updateSummary();
      updateScriptTag();
      renderLintRows();
      if (copyBtn) {
        const hasLints = lintState.items.length > 0;
        copyBtn.disabled = !hasLints;
        copyBtn.setAttribute('aria-disabled', hasLints ? 'false' : 'true');
      }
    }

    function updateFilterButtons() {
      Object.entries(filterButtons).forEach(([key, button]) => {
        if (!button) return;
        const active = Boolean(lintState.filters[key]);
        button.setAttribute('aria-pressed', active ? 'true' : 'false');
      });
    }

    function toggleFilter(key) {
      if (!lintState.filters.hasOwnProperty(key)) {
        return;
      }
      lintState.filters[key] = !lintState.filters[key];
      updateFilterButtons();
      applyFilter();
    }

    function showToast(message) {
      if (!copyToast) return;
      copyToast.textContent = message;
      copyToast.style.display = 'inline-block';
      if (toastTimer) {
        clearTimeout(toastTimer);
      }
      toastTimer = setTimeout(() => {
        copyToast.style.display = 'none';
      }, 2000);
    }

    function fallbackCopy(text) {
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly', '');
        ta.style.position = 'absolute';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      } catch (err) {
        return false;
      }
    }

    async function copyJson() {
      if (!copyBtn) return;
      const text = JSON.stringify(lintState.items, null, 2);
      let success = false;
      copyBtn.disabled = true;
      try {
        if (typeof navigator !== 'undefined' && navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          success = true;
        } else {
          success = fallbackCopy(text);
        }
      } catch (err) {
        success = fallbackCopy(text);
      } finally {
        copyBtn.disabled = false;
      }
      showToast(success ? 'Lints copied' : 'Copy failed');
    }

    const initialLints = parseInitialLints();

    function renderDiff(diff) {
      if (!diffOut) return;
      try {
        diffOut.textContent = JSON.stringify(diff, null, 2);
      } catch (err) {
        diffOut.textContent = '';
      }
    }

    async function previewDiff() {
      if (!diffOut) return;
      diffOut.textContent = 'Loading diff...';
      try {
        const headers = {};
        const key = (adminKey && adminKey.value || '').trim();
        if (key) headers['X-Admin-Key'] = key;
        const res = await fetch('/admin/api/policy/diff', {
          method: 'GET',
          headers,
          credentials: 'same-origin'
        });
        const data = await res.json();
        if (!res.ok) {
          diffOut.textContent = `Failed to load diff (${res.status})`;
          return;
        }
        renderDiff(data && data.diff ? data.diff : {});
      } catch (err) {
        diffOut.textContent = 'Failed to load diff';
      }
    }

    async function reload() {
      msg.textContent = 'Reloading...';
      try {
        const headers = { 'Content-Type': 'application/json', 'X-CSRF-Token': csrf };
        const key = (adminKey && adminKey.value || '').trim();
        if (key) headers['X-Admin-Key'] = key;

        const res = await fetch('/admin/api/policy/reload', {
          method: 'POST',
          headers,
          body: JSON.stringify({ csrf_token: csrf })
        });

        const bodyText = await res.text();
        let data = null;
        try {
          data = bodyText ? JSON.parse(bodyText) : null;
        } catch (err) {
          data = null;
        }

        renderLints(data && data.lints ? data.lints : []);

        if (reloadOut) {
          if (data && data.validation) {
            const issues = Array.isArray(data.validation.issues) ? data.validation.issues : [];
            const mode = data.validation.enforcement_mode || 'warn';
            const lines = issues.map((i) => {
              const sev = String(i.severity || '').toUpperCase();
              const code = i.code ? `[${i.code}]` : '';
              const loc = i.path ? `${i.path}: ` : '';
              return `${sev} ${code} ${loc}${i.message || ''}`.trim();
            });
            const summary = `${res.status} ${data.status || res.statusText || ''} (mode=${mode})`;
            const text = [summary, ...lines.filter(Boolean)].join('\n');
            reloadOut.textContent = text.trim();
          } else {
            const summary = `${res.status} ${res.statusText || ''}`;
            reloadOut.textContent = bodyText ? `${summary}\n${bodyText}`.trim() : summary;
          }
        }

        if (!res.ok) {
          msg.textContent = `Failed (${res.status}): ${bodyText || 'error'}`;
          if (data && data.diff) {
            renderDiff(data.diff);
          }
          return;
        }

        if (data) {
          const resultVersion = data.version || (data.result && data.result.version);
          if (resultVersion) {
            vbox.textContent = resultVersion;
          }
          if (data.diff) {
            renderDiff(data.diff);
          }
        }

        // Fetch packs/version again to keep in sync (optional)
        const vres = await fetch('/admin/api/policy/version');
        if (vres.ok) {
          const vj = await vres.json();
          vbox.textContent = vj.version || vbox.textContent;
        }

        msg.textContent = 'Reloaded.';
        setTimeout(() => { msg.textContent = ''; }, 2000);
      } catch (e) {
        msg.textContent = 'Error reloading.';
        renderLints([]);
      }
      previewDiff();
    }

    async function validatePack() {
      if (!validateOut) return;
      validateOut.textContent = 'Validating...';
      try {
        const headers = { 'Content-Type': 'application/json' };
        const key = (adminKey && adminKey.value || '').trim();
        if (key) headers['X-Admin-Key'] = key;
        const payload = { yaml: packInput ? packInput.value : '' };
        const res = await fetch('/admin/api/policy/validate', {
          method: 'POST',
          headers,
          body: JSON.stringify(payload),
        });
        const data = await res.json();
        const ok = data.status === 'ok';
        const lines = (data.issues || []).map((i) => {
          const loc = i.path ? `${i.path}: ` : '';
          return `${String(i.severity || '').toUpperCase()} [${i.code}] ${loc}${i.message}`;
        });
        validateOut.textContent = `${ok ? 'OK' : 'FAIL'}\n${lines.join('\n')}`;
        renderLints(data && data.lints ? data.lints : []);
      } catch (err) {
        validateOut.textContent = 'Validation failed.';
        renderLints([]);
      }
    }

    if (btn) btn.addEventListener('click', reload);
    if (validateBtn) validateBtn.addEventListener('click', validatePack);
    if (filterButtons.error) filterButtons.error.addEventListener('click', () => toggleFilter('error'));
    if (filterButtons.warn) filterButtons.warn.addEventListener('click', () => toggleFilter('warn'));
    if (filterButtons.info) filterButtons.info.addEventListener('click', () => toggleFilter('info'));
    if (copyBtn) copyBtn.addEventListener('click', () => {
      copyJson();
    });
    document.addEventListener('DOMContentLoaded', () => {
      renderLints(initialLints);
      updateFilterButtons();
      applyFilter();
      previewDiff();
    });
  })();
</script>
{% endblock %}
